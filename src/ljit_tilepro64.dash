|.arch tilepro64
|.section code
|
|// Types
|.type L,		lua_State,	r42
|.type BASE,	TValue,		r43
|.type TOP,		TValue,		r44
|.type CI,		CallInfo,	r45
|.type LCL,		LClosure,	r46
|.type CTOP,	TValue,		r47
|
|// Types
|.type GL,			global_State
|.type TVALUE,		TValue
|.type VALUE,		Value
|.type CINFO,		CallInfo
|.type GCOBJECT,	GCObject
|.type TSTRING,		TString
|.type TABLE,		Table
|.type CCLOSURE,	CClosure
|.type PROTO,		Proto
|.type UPVAL,		UpVal
|.type NODE,		Node
|
|// Definitions copied to DynASM domain to avoid unnecessary constant args.
|// CHECK: must match with the definitions in lua.h!
|.define LUA_TNIL,				0
|.define LUA_TBOOLEAN,			1
|.define LUA_TLIGHTUSERDATA,	2
|.define LUA_TNUMBER,			3
|.define LUA_TSTRING,			4
|.define LUA_TTABLE,			5
|.define LUA_TFUNCTION,			6
|.define LUA_TUSERDATA,			7
|.define LUA_TTHREAD,			8
|
|.define LUA_TNUM_NUM,		0x33
|.define LUA_TNUM_NUM_NUM,	0x333
|.define LUA_TSTR_STR,		0x44
|.define LUA_TSTR_NUM,		0x43
|.define LUA_TSTR_NUM_NUM,	0x433
|.define LUA_TTABLE_NUM,	0x53
|.define LUA_TTABLE_STR,	0x54
|
|
|// Assembler pseudo instructions. Should actually be put in dynasm, putting them here for now
|.macro move, dst, src; or dst, src, zero; .endmacro
|.macro movei, dst, simm8; ori dst, zero, simm8; .endmacro
|.macro moveli, dst, simm16; addli dst, zero, simm16; .endmacro
|.macro movelis, dst, simm16; addlis dst, zero, simm16; .endmacro
|.macro prefetch, src; lb_u zero, src; .endmacro
|.macro bpt; ill; .endmacro
|.macro info, simm8; andi zero, zero, simm8; .endmacro
|.macro infol, simm16; auli zero, zero, simm16; .endmacro
|
|// Own pseudo instructions to handle 32 bit stuff easier
|.macro movewi, dst, simm32
|	addli dst, zero, lo16(simm32)
|	auli dst, dst, ha16(simm32)
|.endmacro
|
|.macro movemwi, dst, simm32
|	addli r25, zero, lo16(simm32)
|	auli r25, r25, ha16(simm32)
|	move dst, r25
|.endmacro
|
|//==================================================================
|// Pseudo instructions specific to this project
|// Stack-related
|.macro prologue, size
|	sw sp, lr
|	addi sp, sp, -size
|.endmacro
|
|.macro epilogue, size
|	addi sp, sp, size
|	lw lr, sp
|.endmacro
|
|.macro loadfromstack, reg, idx
|	addi r25, sp, idx
|	lw reg, r25
|.endmacro
|
|.macro storeonstack, reg, idx
|	addi r25, sp, idx
|	sw r25, reg
|.endmacro
|
|//==========================================================================
|
|.macro preserveglobalregs
|	storeonstack BASE, 8
|	storeonstack L, 12
|	storeonstack TOP, 16
|	storeonstack LCL, 20
|	storeonstack CI, 24
|.endmacro
|
|.macro restoreglobalregs
|	loadfromstack CI, 24
|	loadfromstack LCL, 20
|	loadfromstack TOP, 16
|	loadfromstack L, 12
|	loadfromstack BASE, 8
|.endmacro
|
|//============================================================================
|
|.macro globals_LJ_L, l
|	move L, l
|.endmacro
|
|.macro globals_LJ_BASE, base
|	move BASE, base
|.endmacro
|
|.macro globals_LJ_TOP
|	move TOP, L->top
|.endmacro
|
|.macro globals_LJ_LCL
|	move LCL, BASE->value
|.endmacro
|
|.macro globals_LJ_CI
|	move CI, L->ci
|.endmacro
|
|.macro globals_LJ, base
|	globals_LJ_BASE base
|	globals_LJ_TOP
|	globals_LJ_LCL
|	globals_LJ_CI
|.endmacro
|
|.macro globals_JL_BASE
|	move L->base, BASE
|.endmacro
|
|.macro globals_JL_CI
|	move L->ci, CI
|.endmacro
|
|.macro globals_JL_savedpc
|	move L->savedpc, CI->savedpc
|.endmacro
|
|.macro globals_JL_TOP
|	move L->top, TOP
|.endmacro
|
|.macro globals_JL
|	globals_JL_BASE
|	globals_JL_CI
|	globals_JL_TOP
|	globals_JL_savedpc
|.endmacro
|//=========================================================================
|
|.define LUAFUNC_STACK_SIZE, 8
|
|// Easier word multiply
|.macro mulw_uu, d, a, b
|	mulhl_uu d, a, b
|	mulhla_uu d, b, a
|	shli d, d, 8
|	mullla_uu d, a, b
|	mulhhsa_uu d, a, b
|.endmacro
|
|.macro mulw_ss, d, a, b
|	mulhl_ss d, a, b
|	mulhla_ss d, b, a
|	shli d, d, 8
|	mullla_ss d, a, b
|	mulhhsa_ss d, a, b
|.endmacro
|
|.macro istt, dst, idx, tp; seqi dst, BASE[idx].tt, tp; .endmacro
|.macro isnil, dst, idx; istt dst, idx, LUA_TNIL; .endmacro
|.macro isnumber, dst, idx;  istt dst, idx, LUA_TNUMBER; .endmacro
|.macro isstring, dst, idx;  istt dst, idx, LUA_TSTRING; .endmacro
|.macro istable, dst, idx;  istt dst, idx, LUA_TTABLE; .endmacro
|.macro isfunction, dst, idx;  istt dst, idx, LUA_TFUNCTION; .endmacro
|
|.macro settt, val, tp; move val.tt, tp; .endmacro
|.macro settti, val, tp; movei val.tt, tp; .endmacro
|
|
|.macro copyslot, D, S
|	move D.value, S.value
|	move D.value.na[1], S.value.na[1]
|	move D.tt, S.tt
|.endmacro
|
|
|.macro copyconst, tv, tvk
||switch (ttype(tvk)) {
||case LUA_TNIL:
|   setnilvalue tv
||  break;
||case LUA_TBOOLEAN:
|   setbvalue tv, bvalue(tvk)
||  break;
||case LUA_TNUMBER: {
|   setnvaluek tv, &(tvk)->value
||  break;
||}
||case LUA_TSTRING:
|   setsvalue tv, gcvalue(tvk)
||  break;
||default: lua_assert(0); break;
||}
|.endmacro
|
|
|
|
|.macro loadnvaluek, reg1, reg2, src
|	move reg1, src
|	move reg2, src.na[1]
|//	lw reg1, src
|//	addi reg2, src, 4
|//	lw reg2, reg2
|.endmacro
|
|.macro storenvaluek, dst, reg1, reg2
|	move dst, reg1
|	move dst.na[1], reg2
|//	sw dst, reg1
|//	addi r25, dst, 4
|//	sw r25, reg2
|.endmacro
|
|.macro loadnvalueki, reg1, reg2, src
|	addli r25, zero, lo16(src)
|	auli r25, r25, ha16(src)
|	loadnvaluek reg1, reg2, VALUE:r25[0]
|.endmacro
|
|
|.macro setnvaluek, tv, vptr
|	loadnvalueki r23, r24, vptr
|	storenvaluek tv.value, r23, r24
|	settti tv, LUA_TNUMBER
|.endmacro
|
|.macro setbvalue, tv, val		// May use edx.
||if (val) {  /* true */
|   movei r25, LUA_TBOOLEAN
|   move tv.value, r25		// Assumes: LUA_TBOOLEAN == 1
|   settt tv, r25
||} else {  /* false */
|   movei tv.value, 0
|   settti tv, LUA_TBOOLEAN
||}
|.endmacro
|
|.macro setsvalue, tv, vptr
|	movemwi tv.value, vptr
|	settti tv, LUA_TSTRING
|.endmacro
|
|.macro setnilvalue, tv
|	settti tv, LUA_TNIL
|.endmacro
|
|.macro addidx, dst, src, idx
|	addi dst, src, (idx)*#src
|.endmacro
|
|.macro subidx, dst, src, idx
|	addi dst, src, -(idx)*#src
|.endmacro
|
