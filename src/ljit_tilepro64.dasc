/*
 * Random shit
 */

|.include ljit_tilepro64.dash
|.actionlist jit_actionlist
|.globals JSUB_

/* ------------------------------------------------------------------------ */

/* Arch string. */
const char luaJIT_arch[] = "tilepro64";

/* Forward declarations for C functions called from jsubs. */
static void jit_hookins(lua_State *L, const Instruction *newpc);
static void jit_gettable_fb(lua_State *L, Table *t, StkId dest);
static void jit_settable_fb(lua_State *L, Table *t, StkId val);

/* ------------------------------------------------------------------------ */

/* Detect CPU features and set JIT flags. */
static int jit_cpudetect(jit_State *J)
{
	/* only support for TILEPro64, so ignoring this for now */
	void *mcode;
	size_t sz;
	int status;
	/* Some of the jsubs need the flags. So compile this separately. */
	/*unsigned int feature;
	dasm_setup(Dst, jit_actionlist);
	|  // Check for CPUID support first.
	|  pushfd
	|  pop edx
	|  mov ecx, edx
	|  xor edx, 0x00200000		// Toggle ID bit in flags.
	|  push edx
	|  popfd
	|  pushfd
	|  pop edx
	|  xor eax, eax			// Zero means no features supported.
	|  cmp ecx, edx
	|  jz >1				// No ID toggle means no CPUID support.
	|
	|  inc eax				// CPUID function 1.
	|  push ebx				// Callee-save ebx modified by CPUID.
	|  cpuid
	|  pop ebx
	|  mov eax, edx			// Return feature support bits.
	|1:
	|  ret
	(void)dasm_checkstep(Dst, DASM_SECTION_CODE);
	status = luaJIT_link(J, &mcode, &sz);
	if (status != JIT_S_OK)
	  return status;*/
	/* Check feature bits. See the Intel/AMD manuals for the bit definitions. */
	/*feature = ((unsigned int (*)(void))mcode)();
	if (feature & (1<<15)) J->flags |= JIT_F_CPU_CMOV;
	if (feature & (1<<26)) J->flags |= JIT_F_CPU_SSE2;
	luaJIT_freemcode(J, mcode, sz);*/  /* We don't need this code anymore. */
	return JIT_S_OK;
}

/* Check some assumptions. Should compile to nop. */
static int jit_consistency_check(jit_State *J)
{
/*	do {*/
		/* Force a compiler error for inconsistent structure sizes. */
		/* Check LUA_TVALUE_ALIGN in luaconf.h, too. */
/*		||int check_TVALUE_SIZE_in_ljit_x86_dash[1+TVALUE_SIZE-sizeof(TValue)];
		||int check_TVALUE_SIZE_in_ljit_x86_dash_[1+sizeof(TValue)-TVALUE_SIZE];
		((void)check_TVALUE_SIZE_in_ljit_x86_dash[0]);
		((void)check_TVALUE_SIZE_in_ljit_x86_dash_[0]);
		if (LUA_TNIL != 0 || LUA_TBOOLEAN != 1 || PCRLUA != 0) break;
		if ((int)&(((Node *)0)->i_val) != (int)&(((StkId)0)->value)) break;*/
		return JIT_S_OK;
/*	} while (0);
	J->dasmstatus = 999999999;*/  /* Recognizable error. */
/*	return JIT_S_COMPILER_ERROR;*/
}

/* Compile JIT subroutines (once). */
static int jit_compile_jsub(jit_State *J)
{
	int status = jit_consistency_check(J);
	if (status != JIT_S_OK) return status;
	status = jit_cpudetect(J);
	if (status != JIT_S_OK) return status;
	dasm_setup(Dst, jit_actionlist);
	|// Macros to reorder and combine JIT subroutine definitions.
	|.macro .jsub, name
	|.capture JSUB			// Add the entry point.
	||//-----------------------------------------------------------------------
	||//->name:
	|  .align 16
	|->name:
	|.endmacro
	|.macro .endjsub;  .endcapture; .endmacro
	|.macro .dumpjsub;  .dumpcapture JSUB; .endmacro
	|
	|.code
	|//-----------------------------------------------------------------------
	|.align 64
	|->GATE_LJ:
	|	move BASE, r1
	|	move L, r0
	|	move TOP, L->top
	|	move LCL, BASE->value
	|	move CI, L->ci
	|	// Prevent stackless yield. TODO: figure out what a stackless yield is.
	|	addi L->nCcalls, L->nCcalls, 1

