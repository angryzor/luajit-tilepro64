/*
 * Random shit
 */

|.include ljit_tilepro64.dash
|.actionnames jit_actionnames
|.actionlist jit_actionlist
|.immencmodes jit_encmodes
|.globals JSUB_

/* ------------------------------------------------------------------------ */

/* Arch string. */
const char luaJIT_arch[] = "tilepro64";

/* Forward declarations for C functions called from jsubs. */
static void jit_hookins(lua_State *L, const Instruction *newpc);
static void jit_gettable_fb(lua_State *L, Table *t, StkId dest);
static void jit_settable_fb(lua_State *L, Table *t, StkId val);

/* ------------------------------------------------------------------------ */

/* Detect CPU features and set JIT flags. */
static int jit_cpudetect(jit_State *J)
{
	return JIT_S_OK;
}

/* Check some assumptions. Should compile to nop. */
static int jit_consistency_check(jit_State *J)
{
/*	do {*/
		/* Force a compiler error for inconsistent structure sizes. */
		/* Check LUA_TVALUE_ALIGN in luaconf.h, too. */
/*		||int check_TVALUE_SIZE_in_ljit_x86_dash[1+TVALUE_SIZE-sizeof(TValue)];
		||int check_TVALUE_SIZE_in_ljit_x86_dash_[1+sizeof(TValue)-TVALUE_SIZE];
		((void)check_TVALUE_SIZE_in_ljit_x86_dash[0]);
		((void)check_TVALUE_SIZE_in_ljit_x86_dash_[0]);
		if (LUA_TNIL != 0 || LUA_TBOOLEAN != 1 || PCRLUA != 0) break;
		if ((int)&(((Node *)0)->i_val) != (int)&(((StkId)0)->value)) break;*/
		return JIT_S_OK;
/*	} while (0);
	J->dasmstatus = 999999999;*/  /* Recognizable error. */
/*	return JIT_S_COMPILER_ERROR;*/
}

/* Compile JIT subroutines (once). */
static int jit_compile_jsub(jit_State *J)
{
	int status = jit_consistency_check(J);
	if (status != JIT_S_OK) return status;
	status = jit_cpudetect(J);
	if (status != JIT_S_OK) return status;
	dasm_setup(Dst, jit_actionlist);
	|// Macros to reorder and combine JIT subroutine definitions.
	|.macro .jsub, name
	|.capture JSUB			// Add the entry point.
	||//-----------------------------------------------------------------------
	||//->name:
	|  .align 16
	|->name:
	|.endmacro
	|.macro .endjsub;  .endcapture; .endmacro
	|.macro .dumpjsub;  .dumpcapture JSUB; .endmacro
	|
	|.code
	|//-----------------------------------------------------------------------
	|// Procedure: GATE_LJ(lua_State* L, TValue func, int nresults)
	|//---------------------
	|//.align 64
	|//->GATE_LJ:
	|	prologue 28
	|	// Preserve "global type" registers.
	|	storeonstack BASE, 8
	|	storeonstack L, 12
	|	storeonstack TOP, 16
	|	storeonstack LCL, 20
	|	storeonstack CI, 24
	|
	|	// Init our global types
	|	move BASE, r1
	|	move L, r0
	|	move TOP, L->top
	|	move LCL, BASE->value
	|	move CI, L->ci
	|	// Prevent stackless yield. TODO: figure out what a stackless yield is.
	|	addi L->nCcalls, L->nCcalls, 1
	|
	|	// We need to keep arg 3. We move it to a "callee-saved reg"
	|	// This way, it only gets pushed on the stack if a function wants
	|	// to use this reg, and that's possibly 2 memory ops less
	|	move r20, r2
	|
	|	// Call the compiled code.
	|	jalr LCL->jit_gate
	|
	|	// Set callinfo, set lua state 
	|	move CI, L->ci
	|	move L->top, TOP
	|	move L->savedpc, CI->savedpc
	|	move L->base, CI->base
	|
	|	// Check if arg 3 was LUA_MULTRET
	|	addi r0, r20, 1 
	|	bz r0, >2		// If so, we can skip this
	|
	|	// Multiply number of values on stack by value size
	|	movei r5, #TOP
	|	mulw_uu r4, r2, r5
	|
	|	// Get index right above the last nresults. All 
	|	add BASE, BASE, r4
	|	
	|	// 
	|
	|	// Set all stack slots to nil
	|
	|	// Restore "global type" registers
	|	loadfromstack CI, 24
	|	loadfromstack LCL, 20
	|	loadfromstack TOP, 16
	|	loadfromstack L, 12
	|	loadfromstack BASE, 8
	|	epilogue 28
